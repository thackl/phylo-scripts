#!/usr/bin/env python
import argparse
import sys
import logging
from ete3 import NCBITaxa

__version__='1.3.0'

## parse taxids
# http://etetoolkit.org/docs/latest/tutorial/tutorial_ncbitaxonomy.html
# http://biology.stackexchange.com/questions/45031/how-to-get-taxonomic-specific-ids-for-kingdom-phylum-class-order-family-gen
ncbi = NCBITaxa() # read ncbi tax db

def opts():
    ncbi_ranks = ['subspecies', 'species', 'subgenus', 'genus', 'tribe', 'subfamily',
                  'family', 'superfamily', 'parvorder', 'infraorder', 'suborder',
                  'order', 'superorder', 'parvclass', 'infraclass', 'subclass',
                  'class', 'superclass', 'subphylum', 'phylum', 'kingdom',
                  'superkingdom']

    ## parse args
    parser = argparse.ArgumentParser(
        description='Get lineages for given taxids, and return full lineage certain level(s)')
    parser.add_argument('-t', '--taxids', nargs='?', help="NCBI taxonomy ids (or names) [<stdin>]",
                        type=argparse.FileType('r'), default=sys.stdin)
    parser.add_argument('-r', '--ranks', metavar='rank', nargs='+', help="output rank(s), supported: -r list [genus species]",
                        default=['genus', 'species'], choices=ncbi_ranks)# , type=lambda s: [item for item in s.split(',')])
    parser.add_argument('-n', '--use-names', type=int, choices=range(0,3), default=0, help="0:taxids, 1:names, or 2:names+taxids in output [%(default)s]")
    parser.add_argument('--na', metavar='', help="missing data value [%(default)s]", default=None)
    parser.add_argument('-H', '--no-header', action='store_true', help="omit output header line")
    parser.add_argument('-c', '--comment', metavar='', help="pass-through lines starting with this character [%(default)s]", default="#")
    parser.add_argument('--ncbi-update', action='store_true', help="update the local NCBI Taxonomy database and exit")
    parser.add_argument('-q', '--quiet', action='store_true', help="omit log messages")
    parser.add_argument('--version', action='version', version='%(prog)s-'+__version__)
    opt=parser.parse_args()

    ## logging
    logging.basicConfig(level=logging.INFO if not opt.quiet else logging.WARN,
                        format='[%(asctime)s] %(message)s', datefmt='%m/%d/%Y %H:%M:%S')
    logging.StreamHandler.setFormatter

    return(opt)


def main():

    opt=opts()

    if opt.ncbi_update:
        ncbi.update_taxonomy_database()
        sys.exit()

    logging.info("Reading " + opt.taxids.name)

    if not opt.no_header:
        if opt.use_names == 0:
            print "\t".join([r + "_id" for r in opt.ranks])
        elif opt.use_names == 1:
            print "\t".join([r + "_name" for r in opt.ranks])
        elif opt.use_names == 2:
            print "\t".join(zipl([r + "_name" for r in opt.ranks], [r + "_id" for r in opt.ranks]))

    for tid in opt.taxids: # loop taxids
        tid=tid.rstrip()

        if not tid: # pass-through empty lines
            print
            continue

        if opt.comment and tid[0] == opt.comment: # pass-through comment lines
            print tid
            continue

        if not tid.isdigit(): # non-numeric value
            trans = ncbi.get_name_translator([tid])
            if tid in trans: # could be translated
                tid = str(trans[tid][0])
            else:
                logging.error(" couldn't translate '"+tid+"' into a valid taxid")
                sys.exit()

        tid=int(tid) # tid needs to be int for get lineage!
        lineage = ncbi.get_lineage(tid)
        lineage_ranked = ncbi.get_rank(lineage)
        #print lineage
        ranks = dict(zip(opt.ranks, [None] * len(opt.ranks)))
        for lid, rank in lineage_ranked.items():
            if rank in opt.ranks:
                ranks[rank] = lid

        tids=[ranks[rank] for rank in opt.ranks]
        if opt.use_names == 1:
            tids = ids2names(tids)
        elif opt.use_names == 2:
            tids = zipl(ids2names(tids), tids)

        if opt.na != None: # replace None with custom NA
            tids = [x if x else opt.na for x in tids]

        print "\t".join(str(x) for x in tids)


def zipl(x, y):
    return(val for pair in zip(x, y) for val in pair)

def ids2names(ids):
    return(x[0] for x in (ncbi.translate_to_names([t]) if t else [t] for t in ids))

if __name__ == '__main__':
    main()
