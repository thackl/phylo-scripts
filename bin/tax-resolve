#!/usr/bin/env python
import argparse
import sys
from ete3 import NCBITaxa
import logging

__version__='1.1.0'

def opts():
    ncbi_ranks = ['subspecies', 'species', 'subgenus', 'genus', 'tribe', 'subfamily',
                  'family', 'superfamily', 'parvorder', 'infraorder', 'suborder',
                  'order', 'superorder', 'parvclass', 'infraclass', 'subclass',
                  'class', 'superclass', 'subphylum', 'phylum', 'kingdom',
                  'superkingdom']

    ## parse args
    parser = argparse.ArgumentParser(
        description='Get lineages for given taxids, and return full lineage certain level(s)')
    parser.add_argument('-t', '--taxids', nargs='?', help="List of NCBI taxids (or names) [<stdin>]",
                        type=argparse.FileType('r'), default=sys.stdin)
    parser.add_argument('-q', '--quiet', action='store_true', help="omit log messages")
    parser.add_argument('-r', '--ranks', metavar='rank', nargs='+', help="Taxonomic output level(s) [genus species]; for supported values: -r list",
                        default=['genus', 'species'], choices=[ncbi_ranks], type=lambda s: [item for item in s.split(',')])
    parser.add_argument('-n', '--use-names', type=int, choices=range(0,3), default=0, help="1 for clear names, 2 for taxids and names in output")
    parser.add_argument('--version', action='version', version='%(prog)s-'+__version__)
    opt=parser.parse_args()

    ## logging
    logging.basicConfig(level=logging.INFO if not opt.quiet else logging.WARN,
                        format='[%(asctime)s] %(message)s', datefmt='%m/%d/%Y %H:%M:%S')
    logging.StreamHandler.setFormatter

    return(opt)


def main():

    opt=opts()

    ## parse taxids
    # http://etetoolkit.org/docs/latest/tutorial/tutorial_ncbitaxonomy.html
    # http://biology.stackexchange.com/questions/45031/how-to-get-taxonomic-specific-ids-for-kingdom-phylum-class-order-family-gen
    ncbi = NCBITaxa() # read ncbi tax db
    # ncbi.update_taxonomy_database()

    logging.info("Reading " + opt.taxids.name)


    if opt.use_names == 0:
        print "\t".join([r + "_id" for r in opt.ranks])
    elif opt.use_names == 1:
        print "\t".join([r + "_name" for r in opt.ranks])
    elif opt.use_names == 2:
        print "\t".join(zipl([r + "_name" for r in opt.ranks], [r + "_id" for r in opt.ranks]))

    for tid in opt.taxids: # loop taxids
        tid=tid.rstrip()

        if not tid:
            continue
        if not tid.isdigit(): # non-numeric value
            trans = ncbi.get_name_translator([tid])
            if tid in trans: # could be translated
                tid = str(trans[tid][0])
            else:
                logging.error(" couldn't translate '"+tid+"' into a valid taxid")
                sys.exit()

        lineage = ncbi.get_rank(ncbi.get_lineage(tid))
        #print lineage
        ranks = dict(zip(opt.ranks, [None] * len(opt.ranks)))
        for lid, rank in lineage.items():
            if rank in opt.ranks:
                ranks[rank] = lid

        tids=[ranks[rank] for rank in opt.ranks]
        if opt.use_names == 1:
            tids = ncbi.translate_to_names(tids)
        elif opt.use_names == 2:
            tids = zipl(ncbi.translate_to_names(tids), tids)

        print "\t".join(str(x) for x in tids)


def zipl(x, y):
    return(val for pair in zip(x, y) for val in pair)

if __name__ == '__main__':
    main()
