#!/usr/bin/env perl
# Created: 13 Dec 2017
# Author: Thomas Hackl, thackl@lim4.de
use warnings;
use strict;
use Getopt::Long  qw(:config no_ignore_case bundling);
use Data::Dumper;
use File::Which;
use File::Temp;
use File::Basename;
use Fasta::Parser;

# gff fields
use constant {
    seqid => 0, source => 1, type => 2, start  => 3, end => 4,
    score => 5, strand => 6, phase => 7, attributes => 8,
    len => 9, target => 10, id => 11 # custom
};

GetOptions (
    "targets|t=s" => \(my $opt_targets = "16S,ITS"),
    "strip|s!" => \(my $opt_strip = 1),
    "id-prefix|p=s" => \(my $opt_id),
    "barrnap-opt|B=s" => \(my $opt_barrnap = "--quiet"),
    "ITS-min-length|l=i" => \(my $opt_min_length = 200),
    "ITS-max-length|L=i" => \(my $opt_max_length = 1500),
    "help|h!" => \(my $opt_help),
    "debug|D!" => \(my $debug),
) or die("Error in command line arguments\n");

if ($opt_help || @ARGV==0){
    print "Extract rRNA and ITS sequences from genomic data.\n";
    print "Runs barrnap or parses precomputed gff.\n\n";

    print "Usage: ".(basename($0))." [options] { .fa | .fa .gff | .gff-with-seq } > rRNAs.fa\n";
    printf " %-19s  %s\n", "-t/--targets", "rRNAs and spacer to extract [$opt_targets]";
    printf " %-19s  %s\n", "-s/--strip", "try to strip contig counter from end of sequence IDs used as prefixes [ON]";
    printf " %-19s  %s\n", "-p/--id-prefix", "ID prefix for the extracted sequence [<contig(stripped)>-<target>]";
    printf " %-19s  %s\n", "-l/--ITS-min-length", "Ignore ITS annotated shorter than [$opt_min_length]";
    printf " %-19s  %s\n", "-L/--ITS-max-length", "Ignore ITS annotated longer than [$opt_max_length]";
    printf " %-19s  %s\n", "-B/--barrnap-opt", "Pass-through options for barrnap [$opt_barrnap]";
    printf " %-19s  %s\n", "-h/--help", "show this help";
    printf " %-19s  %s\n", "-D/--debug", "show debug messages";
    exit 0;
}

##----------------------------------------------------------------------------##
# prep input files
my $fa_file = $ARGV[0];
my $gff_file = $ARGV[1];
my $fp;
my ($tmpfh, $tmpfa);
my $bundled = 0;

if (@ARGV==2) { # assume gff and fasta
    if ($fp = Fasta::Parser->new(file=>$fa_file)->check_format){
        print STDERR "Reading from FASTA and precomputed GFF\n";
    }elsif ($fp = Fasta::Parser->new(file=>$ARGV[1])->check_format){ # try GFF/FA
        print STDERR "Reading from precomputed GFF and FASTA\n";
        $fa_file = $ARGV[1];
        $gff_file = $ARGV[0];
    }
    open(GFF, $gff_file) or die $!;
}elsif (@ARGV==1) { # fasta/barnapp or bundled GFF
    if ($fp = Fasta::Parser->new(file=>$fa_file)->check_format){
        print STDERR "Reading from FASTA, annotating rRNAs using barrnap\n";
        my $barrnap = require_exe("barrnap");
        open(GFF, '-|', "$barrnap $opt_barrnap $ARGV[0]") or die $!;
    }else {
        print STDERR "Reading from precomputed GFF, assuming FASTA sequence at the end\n";
        $bundled++;
        $gff_file = $ARGV[0];
        open(GFF, $gff_file) or die $!;
        ($tmpfh, $tmpfa) = File::Temp::tempfile(); # cache FASTA from GFF
        $fp = Fasta::Parser->new(file=>$tmpfa);
    }
}

$debug && print STDERR Dumper({fa_file => $fa_file, gff_file => $gff_file, bundled => $bundled});


##----------------------------------------------------------------------------##
# prep targets
my @targets_all = qw(5S 16S 23S ITS);
my %targets;

for my $t (split(',', $opt_targets )) {
    die "Unknown target $t - aborting\nChoices: ".(join(",", @targets_all))."\n" unless grep{$t eq $_}@targets_all;
    $t =~ s/(\d+S)$/$1-rRNA/;
    $t =~ s/ITS/16S-23S-ITS/;

    $targets{$t}++;
}

$debug && print STDERR Dumper(\%targets);
print STDERR "Searching for ", join(", ", keys %targets), "\n";

##----------------------------------------------------------------------------##
# read input
my %T;
my @S;
my $fasta_from_gff = "";
while (<GFF>) {
    if (/^##FASTA/){ # cache the FASTA sequence
        $bundled || last; # only if bundled
        while (<GFF>) { print $tmpfh $_; }
        last;
    }
    next if /^#/;
    chomp();
    my @r = split("\t", $_);
    next unless $r[type] eq "rRNA";

    $r[start] -= 1; # 0-offset
    $r[len] = $r[end] - $r[start];
    ($r[target]) = $r[attributes] =~ /(\b\d+S\b).*RNA/;
    $r[target].= '-rRNA';
    # store all rRNAs (ITS needs 16S/23S even if not targets
    # $debug && print STDERR Dumper(\@r);
    # only count targets and dependencies
    # $found_c++ if($targets{$1} or ($targets{ITS} && grep{$1}qw(16S 23S))); # TODO: untested
    unless (exists $T{$r[seqid]}){
        $T{$r[seqid]} = [];
        push @S, $r[seqid];
    };
    push @{$T{$r[seqid]}}, \@r;
}
close $tmpfh if $tmpfh; # this is important - reading directly gives incomplete data (buffering)
close GFF;

$debug && print STDERR Dumper(\%T);


##----------------------------------------------------------------------------##
# sort and analyze matched targets
while (my($k, $v) = each %T) { # per contig, sort by coords (to be sure)
    @$v = sort{$a->[start] <=> $b->[start]}@$v;
    if (exists $targets{'16S-23S-ITS'}) { # need to organize rRNA's into consistent cluster to extract ITS properly
        my @ITSs;
        # for each 16S, find adjacent 23S (dir deps on strand, not too far away)
        for (my $i=0; $i<@$v; $i++) {
            my @s16 = @{$v->[$i]};
            next if $s16[target] ne '16S-rRNA';
            my $j = $s16[strand] eq '+' ? $i+1 : $i-1;
            next if ($j<0 || $j>$#$v); # outside seq
            my @s23 = @{$v->[$j]};
            next if $s23[target] ne '23S-rRNA' || # 23S not adjacent
                $s23[strand] ne $s16[strand]; # 16S and 23S not same strand
            my $dist = $s16[strand] eq '+'
                ? $s23[start] - $s16[end]
                : $s16[start] - $s23[end];
            next if $dist > $opt_max_length;

            # OK, this looks like a proper cluster
            my @ITS = @s16;
            $ITS[type] = 'ITS';
            $ITS[attributes] = 'Name=16S-23S-ITS;product=16S-23S internal transcribed spacer';
            $ITS[target] = '16S-23S-ITS';
            ($ITS[start], $ITS[end]) = $s16[strand] eq "+"
                ? ($s16[end], $s23[start])
                : ($s23[end], $s16[start]);
            $ITS[len] = $ITS[end] - $ITS[start];
            push @ITSs, \@ITS;
        }
        # add ITS annotation, and sort by coords;
        push @$v, @ITSs;
        @$v = sort{$a->[start] <=> $b->[start]}@$v;
    }
} # end ITS

$debug && print STDERR Dumper(\%T);


##----------------------------------------------------------------------------##
# TODO: print GFF to file
my %found;
foreach (@S) {
    foreach my $r (@{$T{$_}}){
        next unless exists $targets{$r->[target]};

        # need a unique ID, accounting for cluster-copies
        my $id;
        if (defined($opt_id)) {
            $id = $opt_id;
        }else {
            $id = $r->[seqid];
            $id =~ s/[-._]\d+$// if $opt_strip; # try to strip contig numbers
        }

        $r->[id] = $id."_".$r->[target].".".(++$found{$r->[target]});
        my @gff = @$r[0..8];
        $gff[start]+=1; # 1-offset GFF
        print STDERR join("\t", @gff), "\n"
    }
}

# some meta info for the description
my $source_anno;
my $source_seq;
if ($bundled) {
    $source_anno = basename($gff_file);
    $source_seq = basename($gff_file);
}elsif ($gff_file) {
    $source_anno = basename($gff_file);
    $source_seq = basename($fa_file);
}else {
    $source_anno =$T{(keys %T)[0]}[0][source];
    $source_seq = basename($fa_file);
}



# TODO: convert GFF coordinates to perl substr
## $debug && qx(cp $tmpfa .);

while (my $fs = $fp->next_seq) {
    if ($T{$fs->id}) {
         foreach my $t (@{$T{$fs->id}}) {
             next unless exists $targets{$t->[target]};
             my $ts = $fs->substr_seq($t->[start], $t->[len]); # perl coords 0-offset
             my $id;
             $ts->id($t->[id]);
             $ts->desc("name=$t->[target] source=$t->[seqid] start=$t->[start] ".
                           "end=$t->[end] length=$t->[len] strand=$t->[strand] ".
                           "fasta=$source_seq gff=$source_anno");
             $ts=$ts->reverse_complement if $t->[strand] eq "-";
             print $ts;
         }
     }
 }




################################################################################

sub require_exe{
    my $exe = my $fexe = shift;
    unless ((-e $fexe && -x _) || (($fexe = which($exe)) && -e $fexe && -x _ )){
        warn("$exe .. failed");
        die "$exe not found/executable\n";
    }
    return $fexe;
}
